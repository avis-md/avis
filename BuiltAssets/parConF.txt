#version 330 core

uniform mat4 _P;

in float v2f_id1;
in float v2f_id2;
in vec3 v2f_pos;
in vec3 v2f_wpos1;
in vec3 v2f_wpos2;

uniform vec2 screenSize;

layout (location=0) out vec4 outColor; //rgba
layout (location=1) out vec4 outNormal; //xyz []
layout (location=2) out vec4 outSpec; //spec gloss
layout (location=3) out vec4 outEmi; //emi occlu

void Output(vec4 col, vec3 norm, vec3 spec, float gloss, vec4 emi) {
    outColor = col;
    outNormal.rgb = normalize(norm);
    outNormal.a = 0;
    outSpec.rgb = spec;
    outSpec.a = gloss;
    outEmi = emi;
}

vec2 lli(vec3 p1, vec3 p2, vec3 d1, vec3 d2) {
	float dab = dot(d1, d2);
	if (dab >= 1 || dab <= -1) return vec2(0, 0);
	
	vec3 c = p1 - p2;
	float dac = dot(d1, c);
	float dbc = dot(d2, c);
	
	float num = dbc * dab - dac;
	float div = 1 - dab * dab;
	float resx = num / div;
	float resy = dbc + resx * dab;
	return vec2(resx, resy);
}

void main()
{
	vec3 td = normalize(v2f_wpos2 - v2f_wpos1);
    float L = length(v2f_wpos2 - v2f_wpos1);
	float r = 0.005;
    //*
    vec4 ndc = vec4(
        (gl_FragCoord.x / screenSize.x - 0.5) * 2.0,
        (gl_FragCoord.y / screenSize.y - 0.5) * 2.0,
        (gl_FragCoord.z - 0.5) * 2.0,
        1.0);
    
    vec4 wPos = inverse(_P) * ndc;
    wPos /= wPos.w;
    
    ndc.z = -1;
    vec4 wPos2 = inverse(_P) * ndc;
    wPos2 /= wPos2.w;
    
    vec3 fwd = normalize((wPos - wPos2).xyz);
    
	vec2 lts = lli(wPos2.xyz, v2f_wpos1, fwd, td);
	vec3 p1 = v2f_wpos1 + lts.y * td;
	vec3 p2 = wPos2.xyz + lts.x * fwd;
    
	if (length(p1 - p2) > r) {
        discard;
    }
    else {
		Output(vec4(0, 0, 0, 0), vec3(0, 0, -1), vec3(0.3, 0.3, 0.3), 0.5, vec4(1, 0, 0, 0));
		
		
		/*
		
        vec4 ndc2 = _P * vec4(pf, 1);
        ndc2 /= ndc2.w;
        gl_FragDepth = ndc2.z * 0.5 + 0.5;
		
		
		float isId2 = sign(length(c3 - v2f_wpos1) - L / 2) * 0.5 + 0.5;
		
        Output(vec4(mix(v2f_id1, v2f_id2, isId2), 0, 0, 0), nml, vec3(0.3, 0.3, 0.3), 0.5, vec4(nml, 0));
		*/
	}
}