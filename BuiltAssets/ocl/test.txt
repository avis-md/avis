typedef struct {
	int w;
	int h;
	float IP[16];
	int rnd;
} info_st;

typedef struct {
	float3 pos;
	float3 dir;
} ray_st;

uint Rand(uint rnd) {
	rnd ^= rnd << 13;
	rnd ^= rnd >> 17;
	rnd ^= rnd << 5;
	return rnd;
}

float Len2(float3 vec) {
	return vec.x*vec.x + vec.y*vec.y + vec.z*vec.z;
}

ray_st Refl(ray_st ray, float3 pos, float3 nrm) {
	ray_st res;
	res.pos = pos;
	res.dir = ray.dir - 2 * dot(ray.dir, nrm) * nrm;
	res.pos += res.dir * 0.001f;
	return res;
}

float3 MatMul(float* mat, float3 vec) {
	float3 res;
	res.x = mat[0]*vec.x + mat[4]*vec.y + mat[8]*vec.z + mat[12];
	res.y = mat[1]*vec.x + mat[5]*vec.y + mat[9]*vec.z + mat[13];
	res.z = mat[2]*vec.x + mat[6]*vec.y + mat[10]*vec.z + mat[14];
	float w = mat[3]*vec.x + mat[7]*vec.y + mat[11]*vec.z + mat[15];
	return res / w;
}

float2 BMT(float r1, float r2, float s) {
	float2 res;
	float R = min(log(r1), 1.0f);
	float T = 2 * 3.14159f * r2;
	float mul = pow(1 - s, 2.5f);
	res.x = R * cos(T) * mul;
	res.y = R * sin(T) * mul;
	return res;
}

float3 Rot(float3 vec, float2 r) {
	float3 t1 = (float3)(0, 0, 1);
	float3 t2 = cross(vec, t1);
	t1 = cross(t2, vec);
	return vec*cos(r.x*3.14f)*cos(r.y*3.14f) + t1*sin(r.x*3.14f) + t2*sin(r.y*3.14f);
}

float Int_Ball(ray_st ray, float3 ori, float rad, float3* pos, float3* nrm) {
	float3 L = ori - ray.pos;
	float3 D = ray.dir;
	float lL2 = Len2(L);
	float lD2 = Len2(D);
	float lL = sqrt(lL2);
	L /= lL;
	D /= sqrt(lD2);
	float cs = dot(L, D);
	float isr = lL2*cs*cs - lL2 + rad*rad;
	if (isr < 0) return -1;
	float dst = lL*cs - sqrt(isr);
	if (dst < 0) return -1;
	*pos = ray.pos + ray.dir * dst;
	*nrm = normalize(*pos - ori);
	return dst;
}

ray_st GetRay(info_st info, float2 uv) {
	ray_st ray;
	float3 pos;
	pos.x = uv.x;
	pos.y = uv.y;
	pos.z = -1;
	float3 pos2 = pos;
	pos2.z = 1;
	ray.pos = MatMul(info.IP, pos);
	ray.dir = normalize(MatMul(info.IP, pos2) - pos);
	return ray;
}

float4 SkyAt(float3 dir) {
	float dt = dot(dir, (float3)(-1, 1, -1));
	float cs = acos(dir.y) / 3.14159f;
	if (dt > 1.5f) return (float4)(2,2,2,2);
	else return (float4)(0.5f, 0.5f + 0.7f * cs, 1.5f - 0.7f * cs, 1);
}

float4 Trace(ray_st ray, uint rnd) {
	ray_st rays[5];
	rays[0] = ray;
	float4 res = (float)(1,1,1,1);
	for (int a = 0; a < 4; a++) {
		rnd = Rand(rnd);
		float r1 = 0.001f * (rnd % 1000);
		rnd = Rand(rnd);
		float r2 = 0.001f * (rnd % 1000);
		ray = rays[a];
		float3 hitpos, hitnrm, hp, hn;
		float4 col = (float4)(1, 0.2f, 0.2f, 1);
		float its = Int_Ball(ray, (float3)(-0.2f, -0.2f, 1.2f), 0.8f, &hitpos, &hitnrm);
		float its2 = Int_Ball(ray, (float3)(0.5f, 0.4f, 1.0f), 0.5f, &hp, &hn);
		if ((its < 0) || ((its2 > 0) && (its2 < its))) {
			its = its2;
			hitpos = hp;
			hitnrm = hn;
			col = (float4)(0.8f, 0.4f, 0.2f, 1);
		}
		if (its < 0) {
			return res * SkyAt(ray.dir);
		}
		else res *= col;
		rays[a + 1] = Refl(ray, hitpos, hitnrm);
		rays[a + 1].dir = Rot(rays[a + 1].dir, BMT(r1, r2, 0.8f));
	}
	return (float)(0, 0, 0, 1);
}

float4 GetCol(info_st info, float2 uv) {
	ray_st ray = GetRay(info, uv);
	return Trace(ray, info.rnd);
}

__kernel void _main_(__global float* res, info_st info) {
	size_t id = get_global_id(0);
	float2 uv = (float2)((id % info.w + 0.5f)/info.w, (id / info.w + 0.5f)/info.h);
	uv = uv * 2 - 1;
	
	info.rnd += id;
	float4 col = GetCol(info, uv);
	
	res[id * 4] = col.x;
	res[id * 4 + 1] = col.y;
	res[id * 4 + 2] = col.z;
	res[id * 4 + 3] = col.w;
}