#version 330 core

uniform mat4 _P;

flat in int v2f_id;
in vec3 v2f_pos;
in float v2f_scl;
in float v2f_rad;

uniform vec2 screenSize;

layout (location=0) out vec4 outColor; //rgba
layout (location=1) out vec4 outNormal; //xyz []
layout (location=2) out vec4 outSpec; //spec gloss
layout (location=3) out vec4 outEmi; //emi occlu

void Output(vec4 col, vec3 norm, vec3 spec, float gloss, vec4 emi) {
    outColor = col;
    outNormal.rgb = normalize(norm);
    outNormal.a = 0;
    outSpec.rgb = spec;
    outSpec.a = gloss;
    outEmi = emi;
}

void main()
{
    float R = v2f_rad * v2f_scl;
    //*
    vec4 ndc = vec4(
        (gl_FragCoord.x / screenSize.x - 0.5) * 2.0,
        (gl_FragCoord.y / screenSize.y - 0.5) * 2.0,
        (gl_FragCoord.z - 0.5) * 2.0,
        1.0);
    
    vec4 wPos = inverse(_P) * ndc;
    wPos /= wPos.w;
    
    ndc.z = -1;
    vec4 wPos2 = inverse(_P) * ndc;
    wPos2 /= wPos2.w;
    
    vec3 fwd = normalize((wPos - wPos2).xyz);
    
    vec3 pd = wPos.xyz + fwd * dot(fwd, v2f_pos - wPos.xyz);
    float r = length(pd - v2f_pos);
    if (r > R) {
        discard;
        //gl_FragDepth = gl_FragCoord.z;
        //Output(vec4(0, 0, 0, 0), vec3(0, 0, 0), vec3(0, 0, 0), 0, vec4(0, 1, 0, 0));
    }
    else {
        vec3 s = pd - fwd * sqrt(R*R - r*r);
        
        vec4 ndc2 = _P * vec4(s, 1);
        ndc2 /= ndc2.w;
        gl_FragDepth = ndc2.z * 0.5 + 0.5;
        
        Output(vec4(v2f_id, 0, 0, 0), s - v2f_pos, vec3(0.3, 0.3, 0.3), 0.5, vec4(normalize(s - v2f_pos), 0));
    }
    /*
    vec2 xy = 2.0 * (gl_PointCoord - vec2(0.5, 0.5));
    float r = length(xy);
    if (r > 1) discard;
    float ndcz = 30 * (-((2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far) / (gl_DepthRange.far - gl_DepthRange.near)) * 0.5 + 0.5);
    Output(vec4(v2f_id, 0, 0, 0), vec3(0, 0, 0), vec3(0, 0, 0), 0, vec4(ndcz, 0, 0, 0));
    */
}